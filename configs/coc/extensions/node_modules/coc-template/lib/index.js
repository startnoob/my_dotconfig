(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(__webpack_require__(1));
const path_1 = __webpack_require__(2);
const fs_1 = __webpack_require__(3);
const util_1 = __webpack_require__(4);
const coc_nvim_1 = __webpack_require__(5);
const template_1 = __importDefault(__webpack_require__(7));
function activate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        const { nvim } = coc_nvim_1.workspace;
        const { subscriptions } = context;
        const config = coc_nvim_1.workspace.getConfiguration('template');
        let tmplDir = config.get('templatesDirectory');
        if (tmplDir)
            tmplDir = tmplDir.replace(/^~/, os_1.default.homedir());
        if (!tmplDir)
            tmplDir = context.asAbsolutePath('templates');
        subscriptions.push(coc_nvim_1.commands.registerCommand('template.templateTop', () => __awaiter(this, void 0, void 0, function* () { yield template(nvim, tmplDir, 'top'); })));
        subscriptions.push(coc_nvim_1.commands.registerCommand('template.templateBottom', () => __awaiter(this, void 0, void 0, function* () { yield template(nvim, tmplDir, 'bottom'); })));
        subscriptions.push(coc_nvim_1.commands.registerCommand('template.template', () => __awaiter(this, void 0, void 0, function* () { yield template(nvim, tmplDir, 'cursor'); })));
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'template-top', () => __awaiter(this, void 0, void 0, function* () { yield template(nvim, tmplDir, 'top'); }), { sync: false }));
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'template-bottom', () => __awaiter(this, void 0, void 0, function* () { yield template(nvim, tmplDir, 'bottom'); }), { sync: false }));
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'template', () => __awaiter(this, void 0, void 0, function* () { yield template(nvim, tmplDir, 'cursor'); }), { sync: false }));
        subscriptions.push(coc_nvim_1.listManager.registerList(new template_1.default(nvim, tmplDir)));
    });
}
exports.activate = activate;
function template(nvim, directory, position) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = fs_1.readdirSync(directory) || [];
        if (files.length === 0) {
            coc_nvim_1.workspace.showMessage('Template files were not found', 'warning');
            return;
        }
        const uri = coc_nvim_1.workspace.uri;
        if (!uri) {
            coc_nvim_1.workspace.showMessage('Unknown filetype', 'warning');
            return;
        }
        const fileType = uri.split('.').slice(-1)[0] || null;
        for (const i of Object.keys(files)) {
            if (files[i].split('.').slice(-1)[0] === fileType) {
                const path = coc_nvim_1.Uri.file(path_1.join(directory, files[i])).toString();
                const text = yield util_1.getTmplText(path);
                const content = text.split('\n');
                let lnum;
                switch (position) {
                    case 'top':
                        lnum = 0;
                        break;
                    case 'bottom':
                        lnum = yield nvim.call('line', ["$"]);
                        break;
                    case 'cursor':
                        lnum = yield nvim.call('line', ["."]);
                        break;
                    default:
                        lnum = 0;
                        break;
                }
                const [, rownr, colnr,] = yield nvim.call('getpos', ['.']);
                yield nvim.call('append', [lnum, content]);
                yield util_1.afterAppend(nvim, rownr, colnr);
                return;
            }
        }
        coc_nvim_1.workspace.showMessage('No templates for this filetype', 'warning');
    });
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = __webpack_require__(5);
const child_process_1 = __webpack_require__(6);
function getTmplText(filepath) {
    return __awaiter(this, void 0, void 0, function* () {
        const varMap = new Map();
        const config = coc_nvim_1.workspace.getConfiguration('template');
        const { nvim } = coc_nvim_1.workspace;
        let dateObj = new Date();
        let day = dateObj.getDate().toString();
        let year = dateObj.getFullYear().toString();
        let month = (dateObj.getMonth() + 1).toString();
        let hour = dateObj.getHours();
        let minute = dateObj.getMinutes();
        let time = `${hour}:${minute}`;
        let date = `${year}-${month}-${day}`;
        let fdate = date + ' ' + time;
        let monthshort = yield nvim.call('strftime', '%b');
        let monthfull = yield nvim.call('strftime', '%B');
        let filen = yield nvim.call('expand', "%:t:r:r:r");
        let filex = yield nvim.call('expand', '%:e');
        let filec = yield nvim.call('expand', '%:t');
        let fdir = yield nvim.call('expand', '%:p:h:t');
        let class_ = yield nvim.call('substitute', [filen, '\\([a-zA-Z]\\+\\)', '\\u\\1\\e', 'g']); // todo
        let macroClass = class_.toString().toUpperCase();
        let camelClass = class_.toString().replace(/_/g, '', 'g');
        let guard = filec.toString().replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
        let email = yield getVars(config, 'email');
        let username = yield getVars(config, 'username');
        let license = yield getVars(config, 'license');
        let hostn = yield nvim.call('hostname');
        varMap.set('%DAY%', day);
        varMap.set('%YEAR%', year);
        varMap.set('%TIME%', time);
        varMap.set('%FDATE%', fdate);
        varMap.set('%MONTH%', month);
        varMap.set('%MONTHFULL%', monthfull);
        varMap.set('%MONTHSHORT%', monthshort);
        varMap.set('%FILE%', filen);
        varMap.set('%FFILE%', filec);
        varMap.set('%FDIR%', fdir);
        varMap.set('%EXT%', filex);
        varMap.set('%MAIL%', email);
        varMap.set('%USER%', username);
        varMap.set('%LICENSE%', license);
        varMap.set('%HOST%', hostn);
        varMap.set('%GUARD%', guard);
        varMap.set('%CLASS%', class_);
        varMap.set('%MACROCLASS%', macroClass);
        varMap.set('%CAMELCLASS%', camelClass);
        let re = new RegExp([...varMap.keys()].join('|'), 'gi');
        let text = yield coc_nvim_1.workspace.readFile(filepath);
        text = text.replace(re, match => varMap.get(match));
        text = text.replace(/\n*$/g, '');
        return text;
    });
}
exports.getTmplText = getTmplText;
function getVars(config, varname) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (varname) {
            case 'email':
                {
                    const email = config.get('email');
                    if (email) {
                        return email;
                    }
                    else {
                        return new Promise(resolve => {
                            const cmd = 'git config --global user.email';
                            child_process_1.exec(cmd, (err, stdout) => {
                                if (err)
                                    resolve(email);
                                else
                                    resolve(stdout.trim());
                            });
                        });
                    }
                }
            case 'username':
                {
                    const username = config.get('username');
                    if (username) {
                        return username;
                    }
                    else {
                        return new Promise(resolve => {
                            const cmd = 'git config --global user.name';
                            child_process_1.exec(cmd, (err, stdout) => {
                                if (err)
                                    resolve(username);
                                else
                                    resolve(stdout.trim());
                            });
                        });
                    }
                }
            case 'license': {
                return config.get('license') || 'MIT';
            }
            default:
                break;
        }
    });
}
function afterAppend(nvim, rownr, colnr) {
    return __awaiter(this, void 0, void 0, function* () {
        // Delete the last line which is empty after appending
        const remain = yield nvim.eval('join(getline(".", "$"))');
        if (remain.toString().trim() === '') {
            yield nvim.command('undojoin | normal! Gdd');
        }
        yield nvim.command('0');
        const here = yield nvim.call('search', ['%HERE%', 'W']);
        if (here) {
            const saveReg = yield nvim.call('getreg', '"');
            yield nvim.command('undojoin | s/%HERE%//');
            yield nvim.call('setreg', ['"', saveReg]);
            const pos = yield nvim.call('getpos', ['.']);
            rownr = pos[1];
            colnr = pos[2];
        }
        yield nvim.call('cursor', [rownr, colnr]);
    });
}
exports.afterAppend = afterAppend;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("coc.nvim");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __webpack_require__(3);
const path_1 = __webpack_require__(2);
const coc_nvim_1 = __webpack_require__(5);
const util_1 = __webpack_require__(4);
class Template extends coc_nvim_1.BasicList {
    constructor(nvim, directory) {
        super(nvim);
        this.directory = directory;
        this.name = 'templates';
        this.description = 'Code templates for certain file types';
        this.defaultAction = 'append';
        this.actions = [];
        this.addLocationActions();
        this.addAction('append', (item) => __awaiter(this, void 0, void 0, function* () {
            const [, rownr, colnr,] = yield nvim.call('getpos', ['.']);
            const text = yield util_1.getTmplText(item.location);
            const content = text.split('\n');
            nvim.call('append', [rownr - 1, content], true);
            yield util_1.afterAppend(nvim, rownr, colnr);
        }));
    }
    loadItems(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            const list = [];
            const files = fs_1.readdirSync(this.directory) || [];
            files.forEach(file => {
                list.push({
                    label: `${file}`,
                    filterText: file,
                    location: coc_nvim_1.Uri.file(path_1.join(this.directory, file)).toString()
                });
            });
            return list;
        });
    }
    doHighlight() {
        let { nvim } = coc_nvim_1.workspace;
        nvim.pauseNotification();
        nvim.command('syntax match TemplateFile /\\v.*/', true);
        nvim.command('highlight default link TemplateFile Identifier', true);
        nvim.resumeNotification().catch(_e => {
            // no op
        });
    }
}
exports.default = Template;


/***/ })
/******/ ])));